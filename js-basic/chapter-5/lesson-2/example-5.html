<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /*********************************************
     * Возврат функции
     *********************************************/

    /**
     * Рассмотрим более «продвинутый» вариант, при котором внутри одной функции
     * создаётся другая и возвращается в качестве результата.
     *
     * В разработке интерфейсов это совершенно стандартный приём, функция затем
     * может назначаться как обработчик действий посетителя.
     *
     * Здесь мы будем создавать функцию-счётчик, которая считает свои вызовы и возвращает их текущее число.
     *
     * В примере ниже makeCounter создает такую функцию:
     */
    function makeCounter() {
        var currentCount = 1;
        return function () { // **
            return currentCount++;
        }
    }

    // каждый вызов увеличивает счётчик и возвращает результат
    var counter = makeCounter(); // *
    alert(counter()); // 1
    alert(counter()); // 2
    alert(counter()); // 3

    // создать другой счётчик, он будет независим от первого
    var counter2 = makeCounter();
    alert(counter2()); // 1

    /**
     * Как видно, мы получили два независимых счётчика counter и counter2, каждый из которых
     * незаметным снаружи образом сохраняет текущее количество вызовов.
     *
     * Где? Конечно, во внешней переменной currentCount, которая у каждого счётчика своя.
     *
     * Если подробнее описать происходящее:
     * 1)   В строке (*) запускается makeCounter(). При этом создаётся LexicalEnvironment для переменных текущего вызова.
     *      В функции есть одна переменная var currentCount, которая станет свойством этого объекта.
     *      Она изначально инициализуется в undefined, затем, в процессе выполнения, получит значение 1:
     * 2)   В процессе выполнения makeCounter() создаёт функцию в строке (**).
     *      При создании эта функция получает внутреннее свойство [[Scope]]
     *      со ссылкой на текущий LexicalEnvironment.
     * 3)   Далее вызов makeCounter() завершается и функция (**) возвращается и
     *      сохраняется во внешней переменной counter (*).
     *
     * На этом создание «счётчика» завершено.
     * Итоговым значением, записанным в переменную counter, является функция:
     * Возвращённая из makeCounter() функция counter помнит (через [[Scope]]) о том, в каком окружении была создана.
     * Это и используется для хранения текущего значения счётчика.
     *
     * Далее, когда-нибудь, функция counter будет вызвана. Мы не знаем, когда это произойдёт.
     * Может быть, прямо сейчас, но, вообще говоря, совсем не факт.
     *
     * Эта функция состоит из одной строки: return currentCount++,
     * ни переменных ни параметров в ней нет, поэтому её собственный объект переменных,
     * для краткости назовём его LE – будет пуст.
     *
     * Однако, у неё есть свойство [[Scope]], которое указывает на внешнее окружение.
     * Чтобы увеличить и вернуть currentCount, интерпретатор ищет в текущем объекте переменных LE,
     * не находит, затем идёт во внешний объект, там находит, изменяет и возвращает новое значение:
     */
    function makeCounter() {
        var currentCount = 1;
        return function () {
            return currentCount++;
        }
    }
    var counter = makeCounter(); // [[Scope]] -> { currentCount: 1 }
    alert(counter());
    alert(counter());
    alert(counter());

    /**
     * !!! Переменную во внешней области видимости можно не только читать, но и изменять.
     *
     * В примере выше было создано несколько счётчиков. Все они взаимно независимы:
     */
    var counter = makeCounter();

    var counter2 = makeCounter();

    alert(counter()); // 1
    alert(counter()); // 2
    alert(counter()); // 3

    alert(counter2()); // 1

    /**
     * Они независимы, потому что при каждом запуске makeCounter создаётся свой объект переменных LexicalEnvironment,
     * со своим свойством currentCount, на который новый счётчик получит ссылку [[Scope]].
     */
</script>
</body>
</html>