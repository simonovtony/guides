<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /*******************************************************
     * Алгоритм сборки мусора
     *******************************************************/

    /**
     * Сборщик мусора идёт от корня по ссылкам и запоминает
     * все найденные объекты. По окончанию – он смотрит, какие
     * объекты в нём отсутствуют и удаляет их.
     *
     * Например, рассмотрим пример объекта «семья»:
     */
    function marry(man, woman) {
        woman.hasband = man;
        man.wife = woman;

        return {
            father: man,
            mother: woman
        }
    }

    var family = marry({
        name: 'Василий'
    }, {
        name: 'Мария'
    });

    /**
     * Функция marry принимает два объекта, даёт им ссылки друг
     * на друга и возвращает третий, содержащий ссылки на оба.
     *
     * Получившийся объект family можно изобразить так:
     *
     * Здесь стрелочками показаны ссылки, а вот свойство name
     * ссылкой не является, там хранится примитив, поэтому оно
     * внутри самого объекта.
     *
     * Чтобы запустить сборщик мусора, удалим две ссылки:
     */
    delete family.father;
    delete family.mother.hasband;

    /**
     * Обратим внимание, удаление только одной из этих ссылок
     * ни к чему бы не привело. Пока до объекта можно добраться
     * из корня window, объект остаётся жив.
     *
     * А если две, то получается, что от бывшего family.father
     * ссылки выходят, но в него – ни одна не идёт:
     *
     * !!! Совершенно неважно, что из объекта выходят какие-то ссылки,
     *     они не влияют на достижимость этого объекта.
     *
     * Бывший family.father стал недостижимым и будет удалён вместе со
     * своими данными, которые также более недоступны из программы.
     *
     * А теперь – рассмотрим более сложный случай. Что будет, если
     * удалить главную ссылку family?
     *
     * Исходный объект – тот же, что и в начале, а затем:
     */
    window.family = null;

    /**
     * Результат:
     *
     * Как видим, объекты в конструкции всё ещё связаны между собой.
     * Однако, поиск от корня их не находит, они не достижимы, и
     * значит сборщик мусора удалит их из памяти.
     */

    /**
     * !!! Оптимизации
     *
     * Проблема описанного алгоритма – в больших задержках. Если объектов
     * много, то на поиск всех достижимых уйдёт довольно много времени.
     * А ведь выполнение скрипта при этом должно быть остановлено, уже
     * просканированные объекты не должны поменяться до окончания процесса.
     * Получаются небольшие, но неприятные паузы-зависания в работе скрипта.
     *
     * Поэтому современные интерпретаторы применяют различные оптимизации.
     *
     * Самая частая – это деление объектов на два вида «старые» и «новые».
     * Для каждого типа выделяется своя область памяти. Каждый объект создаётся
     * в «новой» области и, если прожил достаточно долго, мигрирует в старую.
     * «Новая» область обычно небольшая. Она очищается часто. «Старая» – редко.
     *
     * На практике получается эффективно, обычно большинство объектов создаются
     * и умирают почти сразу, к примеру, служа локальными переменными функции:
     */
    function showTime() {
        alert(new Date()); // этот объект будет создан и умрёт сразу
    }
    showTime();

    /**
     * Если вы знаете низкоуровневые языки программирования, то более подробно
     * об организации сборки мусора в V8 можно почитать, например, в статье
     * A tour of V8: Garbage Collection.
     */
</script>
</body>
</html>