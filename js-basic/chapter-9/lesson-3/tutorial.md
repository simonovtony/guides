# Втроенные "классы" в JavaScript

В JavaScript есть встроенные объекты: Date, Array, Object и другие. Они используют прототипы и демонстрируют организацию «псевдоклассов» на JavaScript, которую мы вполне можем применить и для себя.

## Откуда методы у {}?

Начнём мы с того, что создадим пустой объект и выведем его.

`example-1.html`

Где код, который генерирует строковое представление для alert(obj)? Объект-то ведь пустой.

## Object.prototype

…Конечно же, это сделал метод toString, который находится… Конечно, не в самом объекте (он пуст), а в его прототипе obj.__proto__, можно его даже вывести:

`example-2.html`

Откуда новый объект obj получает такой __proto__?

1. Запись obj = {} является краткой формой obj = new Object, где Object – встроенная функция-конструктор для объектов.

2. При выполнении new Object, создаваемому объекту ставится __proto__ по prototype конструктора, который в данном случае равен встроенному Object.prototype.

3. В дальнейшем при обращении к obj.toString() – функция будет взята из Object.prototype.

Это можно легко проверить:

`example-3.html`

## Встроенные "классы" в JavaScript

Точно такой же подход используется в массивах Array, функциях Function и других объектах. Встроенные методы для них находятся в Array.prototype, Function.prototype и т.п.

Например, когда мы создаём массив, [1, 2, 3], то это альтернативный вариант синтаксиса new Array, так что у массивов есть стандартный прототип Array.prototype.

Но в нём есть методы лишь для массивов, а для общих методов всех объектов есть ссылка Array.prototype.__proto__, равная Object.prototype.

Аналогично, для функций.

Лишь для чисел (как и других примитивов) всё немного иначе, но об этом чуть далее.

Объект Object.prototype – вершина иерархии, единственный, у которого __proto__ равно null.

#### Поэтому говорят, что "все объекты наследуют от Object", а если более точно, то от Object.prototype.

«Псевдоклассом» или, более коротко, «классом», называют функцию-конструктор вместе с её prototype. Такой способ объявления классов называют «прототипным стилем ООП».

При наследовании часть методов переопределяется, например, у массива Array есть свой toString, который выводит элементы массива через запятую:

`example-4.html`

Как мы видели раньше, у Object.prototype есть свой toString, но так как в Array.prototype он ищется первым, то берётся именно вариант для массивов:

#### Вызов методов через call и apply из прототипа

Ранее мы говорили о применении методов массивов к «псевдомассивам», например, можно использовать [].join для arguments:

`example-5.html`

Так как метод join находится в Array.prototype, то можно вызвать его оттуда напрямую, вот так:

`example-6.html`

Это эффективнее, потому что не создаётся лишний объект массива [], хотя, с другой стороны – больше букв писать.

## Примитивы

Примитивы не являются объектами, но методы берут из соответствующих прототипов: Number.prototype, Boolean.prototype, String.prototype.

По стандарту, если обратиться к свойству числа, строки или логического значения, то будет создан объект соответствующего типа, например new String для строки, new Number для чисел, new Boolean – для логических выражений.

Далее будет произведена операция со свойством или вызов метода по обычным правилам, с поиском в прототипе, а затем этот объект будет уничтожен.

Именно так работает код ниже:

`example-7.html`

Можно даже попробовать записать в этот временный объект свойство:

`example-8.html`

Свойство age было записано во временный объект, который был тут же уничтожен, так что смысла в такой записи немного. Пример выше выполняется без use strict, в строгом режиме была бы ошибка, и это хорошо, так как такая запись, по большому счету, не имеет смысла.

#### Конструкторы String/Number/Boolean – только для внутреннего использования

Технически, можно создавать объекты для примитивов и вручную, например new Number. Но в ряде случаев получится откровенно бредовое поведение. Например:

`example-9.html`

Или, ещё страннее:

`example-10.html`

Поэтому в явном виде new String, new Number и new Boolean никогда не вызываются.

#### Значения null и undefined не имеют свойств

Значения null и undefined стоят особняком. Вышесказанное к ним не относится.

Для них нет соответствующих классов, в них нельзя записать свойство (будет ошибка), в общем, на конкурсе «самое примитивное значение» они точно разделили бы первое место.

## Изменение встроенных прототипов

Встроенные прототипы можно изменять. В том числе – добавлять свои методы.

Мы можем написать метод для многократного повторения строки, и он тут же станет доступным для всех строк:

`example-11.html`

Аналогично мы могли бы создать метод Object.prototype.each(func), который будет применять func к каждому свойству:

`example-12.html`

Обратите внимание – пример выше работает не совсем корректно. Вместе со свойствами объекта user он выводит и наше свойство each. Технически, это правильно, так как цикл for..in перебирает свойства и в прототипе тоже, но не очень удобно.

Конечно, это легко поправить добавлением проверки hasOwnProperty:

`example-13.html`

Здесь это сработало, теперь код работает верно. Но мы же не хотим добавлять hasOwnProperty в цикл по любому объекту! Поэтому либо не добавляйте свойства в Object.prototype, либо можно использовать дескриптор свойства и флаг enumerable.

Это, конечно, не будет работать в IE8-:

`example-14.html`

#### Достоинства

* Методы в прототипе автоматически доступны везде, их вызов прост и красив.

#### Недостатки

* Новые свойства, добавленные в прототип из разных мест, могут конфликтовать между собой. Представьте, что вы подключили две библиотеки, которые добавили одно и то же свойство в прототип, но определили его по-разному. Конфликт неизбежен.

* Изменения встроенных прототипов влияют глобально, на все-все скрипты, делать их не очень хорошо с архитектурной точки зрения.


Как правило, минусы весомее, но есть одно исключение, когда изменения встроенных прототипов не только разрешены, но и приветствуются.

#### Допустимо изменение прототипа встроенных объектов, которое добавляет поддержку метода из современных стандартов в те браузеры, где её пока нет.

Например, добавим Object.create(proto) в старые браузеры:

`example-15.html`

Именно так работает библиотека es5-shim, которая предоставляет многие функции современного JavaScript для старых браузеров. Они добавляются во встроенные объекты и их прототипы.

## Итого

* Методы встроенных объектов хранятся в их прототипах.

* Встроенные прототипы можно расширить или поменять.

* Добавление методов в Object.prototype, если оно не сопровождается Object.defineProperty с установкой enumerable (IE9+), «сломает» циклы for..in, поэтому стараются в этот прототип методы не добавлять.


Другие прототипы изменять менее опасно, но все же не рекомендуется во избежание конфликтов.


Отдельно стоит изменение с целью добавления современных методов в старые браузеры, таких как Object.create, Object.keys, Function.prototype.bind и т.п. Это допустимо и как раз делается es5-shim.

