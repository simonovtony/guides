# Генераторы

Генераторы - новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать свое выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.

## Создание генератора

Для обьявления генератора, используется новая синтаксическая конструкция: function* (функция со звездочкой).

Ее называют "функция-генератор" (generator function).

Выглядит это так:

`example-1.html`

При запуске generatorSequence() код такой функции не выполняется. Вместо этого она возвращает специальный обьект, который как раз и называют "генератором".

`example-2.html`

Правильнее всего будет воспринимать генератор как "замороженный вызов функции":

При создании генератора код находится в начале своего выполнения.

Основным методом генератора является next(). При вызове он возобновляет выполнения кода до ближайшего ключевого слова yield. По достижении yield выполнение приостанавливается, а значение возвращается во внешний код:

`example-3.html`

Повторный вызов generator.next() возобновит выполнение и вернет результат следующего yield:

`example-4.html`

И, наконец, последний вызов завершит выполнение функции и вернет результат return:

`example-5.html`

Функция завершена. Внешний код должен увидеть это из свойства done: true и обработать value: 3, как окончательный результат.

Новые вызовы generator.next() больше не имеют смысла. Впрочем если они и будут, то не вызовут ошибки, но будут возвращать один и тот же обьект: { done: true }.

"Открутить назад" завершившийся генератор нельзя, но можно создать новый еще одним вызовом generatorSequence() и выполнить его.

#### function* (...) или function *(...)?

Можно ставить звездочку как сразу после function, так и позже, перед названием. В интернете можно найти обе эти формы записи, они верны:

    function* f() {
        // звездочка после function
    }

    function *f() {
        // звездочка перед названием
    }

Технически, нет разницы, но писать то так то эдак - довольно странно, надо остановится на чем то одном.

Автор данного текста пологает, что правильнее использовать первый вариант function*, так как звездочка относится к типу обьявляемой сущьности (function* - "функция генератор"), а не к ее названию. Конечно, это всего лишь рекомендация-мнение, не обязательное к выполнению, работать будет в любом случае.

## Генератор-итератор

Как вы, наверное, уже догадались по наличию метода next(), генератор связан с итераторами. В частности он является итерируемым обьектом.

Его можно перебирать и через for..of:

`example-6.html`

Заметим, однако, существенную особенность такого перебора!

При запуске примера выше будет выведено значение 1, затем 2. Значение 3 выведено не будет. Это потому что стандартный перебор итератора игнорирует value на последнем значении, при done: true. Так что результат return в цикле for..of не выводится.

Соответственно, если мы хотим, чтобы все значения возвращались при переборе через for..of, то надо возвращать их через yield:

`example-7.html`

...А зачем вообще return при таком расскладе, если его результат игнорируется? Он тоже нужен, но в других ситуациях. Перебор через for..of - в некотором смысле "исключение". Как мы увидим дальше, в других контекстах return очень даже востребован.

## Композиция генераторов

Один генератор может включать в себя другие. Это называется композицией.

Разберем композицию на примере.

Пусть у нас есть функция generatorSequence, которая генерирует последовательность чисел:

`example-8.html`

Мы хотим на ее основе сделать другую функцию generatorAlphaNum(), которая будет генерировать коды для буквенно-цифровых символов латинского алфавита:

* 48..57 - для 0..9

* 65..90 - для A..Z

* 97..122 - для a..z

Для этого набора кодов можно превратить в строку и использовать, к примеру, для выбора из него случайного пароля. Только символы пунктуации еще хорошо бы добавить для надежности, но в этом примере мы будем без них.

Естественно, раз в нашем распоряжении есть готовый генератор generateSequence, то хорошо бы его использовать.

Конечно, можно внутри generateAlphaNum запустить несколько раз generateSequence, обьеденить результаты и вернуть. Так мы бы сделали с обычными функциями. Но композиция - это кое-что получше.

Она выглядит так:

`example-9.html`

Здесь использована специальная форма yield*. Она применима только к другому генератору и делегирует ему выполнение.

То есть, при yield* интерпретатор переходит внутрь генератора аргумента, к примеру generateSequence(48, 57), выполняет его, и все yield, которые он делает выходят из внешнего генератора.

Получается - как будто мы вставили код внутреннего генератора во внешний напрямую, вот так:

`example-10.html`

Код выше по поведению полностью идентичен варианту с yield*. При этом, конечно, переменные вложенного генератора не попадают во внешний, "делегирование" только выводит результат yield во внешний поток.

Композиция - это естественное встраивание одного генератора в поток другого. При композиции значения из вложенного генератора выдаются "по мере готовности". Поэтому она будет работать даже если поток данных из вложеного генератора оказался бесконечным или ожидает какого-либо условия для завершения.

## yield - дорога в обе стороны

До этого генераторы наиболее напоминали "итераторы на стероидах". Но, как мы сейчас увидим, это не так, есть фундаментальное различие, генераторы гораздо мощьнее и гибче.

Всё дело в том что yield - дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор.

Вызов let result = yield value делает следующее:

* Возвращает value во внешний код, приостанавливая выполнение генератора.

* Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).

* Генератор продолжит выполнение, аргумент next будет возвращен как результат yield (и записан в result).

Продемонстрируем это на примере:

`example-11.html`

На рисунке ниже прямоугольником изображен генератор, а вокруг него - "внешний код", с ним взаимодействует:

На этой илюстрации показано то, что происходит в генераторе:

1. Первый вызов generator.next() - всегда без аргумента, он начинает выполнение и возвращает результат первого yield "2 + 2?". На этой точке генератор приостанавливает выполнение.

2. Результат yield переходит во внешний код (в question). Внешний код может выполнять любые асинхронные задачи, генератор стоит "на паузе".

3. Когда асинхронные задачи готовы, внешний код вызывает generator.next(4) с аргументом. Выполнение генератора возобновляется, а 4 выходит из присваивания как результат let result = yield ....

В примере выше только 2 next.

Увеличим их количество, чтобы стал более понятен общий поток выполнения:

`example-12.html`

Взаимодействие с внешним кодом:

1. Первый .next() начинает выполнение... Оно доходит до первого yield.

2. Результат возвращается во внешний код.

3. Второй .next(4) передает 4 обратно в генератор как результат первого yield и возобновляет выполнение.

4. ...Оно доходит до второго yield, который станет результатом .next(4).

5. Третий next(9) передает 9 в генератор как результат второго yield и возобновляет выполнение, которое завершается окончанием функции, так что done: true.

Получается "пинг-понг" каждый next(value) передает в генератор значение, которое становится результатом текущего yield, возобновляет выполнение и получает выражение из следующего yield. Исключение является первый вызов next, который не может передать значение в генератор, т.к. не было ни одного yield.

## generator.throw 

Как мы видели в примерах выше, внешний код может вернуть генератору в качестве результата yield любое значение.

... Но "вернуть" можно не только результат, но и ошибку!

Для того, чтобы передать в yield ошибку, используется вызов generator.throw(err). При этом на строке с yield возникает исключение.

Например, в коде ниже обращение к внешниму коду yield "Сколько будет 2 + 2" завершится с ошибкой:

`example-13.html`

"Выброшенная" в строке (*) ошибка возникает в строке с yield (**). Далее она обрабатывается как обычно. В примере выше она перехватывается try..catch и выводится.

Если ошибку не перехватить, то она "выпадает" из генератора. По стеку ближайший вызов, который инициировал выполнение - это строка с .throw. Можно прехватить ее там, как и продемонстрированно в примере ниже:

`example-14.html`

Если же ошибка и там не перехвачена, то дальше - как обычно, либо try..catch снаружи, либо она "повалит" скрипт.

## Плоский асинхронный код

Одна из основных областей применения генераторов - написание "плоского" асинхронного кода.

Общий принцип такой:

