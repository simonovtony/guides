# Генераторы

Генераторы - новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать свое выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.

## Создание генератора

Для обьявления генератора, используется новая синтаксическая конструкция: function* (функция со звездочкой).

Ее называют "функция-генератор" (generator function).

Выглядит это так:

`example-1.html`

При запуске generatorSequence() код такой функции не выполняется. Вместо этого она возвращает специальный обьект, который как раз и называют "генератором".

`example-2.html`

Правильнее всего будет воспринимать генератор как "замороженный вызов функции":

При создании генератора код находится в начале своего выполнения.

Основным методом генератора является next(). При вызове он возобновляет выполнения кода до ближайшего ключевого слова yield. По достижении yield выполнение приостанавливается, а значение возвращается во внешний код:

`example-3.html`

Повторный вызов generator.next() возобновит выполнение и вернет результат следующего yield:

`example-4.html`

И, наконец, последний вызов завершит выполнение функции и вернет результат return:

`example-5.html`

Функция завершена. Внешний код должен увидеть это из свойства done: true и обработать value: 3, как окончательный результат.

Новые вызовы generator.next() больше не имеют смысла. Впрочем если они и будут, то не вызовут ошибки, но будут возвращать один и тот же обьект: { done: true }.

"Открутить назад" завершившийся генератор нельзя, но можно создать новый еще одним вызовом generatorSequence() и выполнить его.

#### function* (...) или function *(...)?

Можно ставить звездочку как сразу после function, так и позже, перед названием. В интернете можно найти обе эти формы записи, они верны:

    function* f() {
        // звездочка после function
    }

    function *f() {
        // звездочка перед названием
    }

Технически, нет разницы, но писать то так то эдак - довольно странно, надо остановится на чем то одном.

Автор данного текста пологает, что правильнее использовать первый вариант function*, так как звездочка относится к типу обьявляемой сущьности (function* - "функция генератор"), а не к ее названию. Конечно, это всего лишь рекомендация-мнение, не обязательное к выполнению, работать будет в любом случае.

## Генератор-итератор

Как вы, наверное, уже догадались по наличию метода next(), генератор связан с итераторами. В частности он является итерируемым обьектом.

Его можно перебирать и через for..of:

`example-6.html`

Заметим, однако, существенную особенность такого перебора!

При запуске примера выше будет выведено значение 1, затем 2. Значение 3 выведено не будет. Это потому что стандартный перебор итератора игнорирует value на последнем значении, при done: true. Так что результат return в цикле for..of не выводится.

Соответственно, если мы хотим, чтобы все значения возвращались при переборе через for..of, то надо возвращать их через yield:

`example-7.html`

...А зачем вообще return при таком расскладе, если его результат игнорируется? Он тоже нужен, но в других ситуациях. Перебор через for..of - в некотором смысле "исключение". Как мы увидим дальше, в других контекстах return очень даже востребован.

## Композиция генераторов

Один генератор может включать в себя другие. Это называется композицией.

Разберем композицию на примере.

Пусть у нас есть функция generatorSequence, которая генерирует последовательность чисел:

`example-8.html`

Мы хотим на ее основе сделать другую функцию generatorAlphaNum(), которая будет генерировать коды для буквенно-цифровых символов латинского алфавита:

* 48..57 - для 0..9

* 65..90 - для A..Z

* 97..122 - для a..z

Для этого набора кодов можно превратить в строку и использовать, к примеру, для выбора из него случайного пароля. Только символы пунктуации еще хорошо бы добавить для надежности, но в этом примере мы будем без них.

Естественно, раз в нашем распоряжении есть готовый генератор generateSequence, то хорошо бы его использовать.

Конечно, можно внутри generateAlphaNum запустить несколько раз generateSequence, обьеденить результаты и вернуть. Так мы бы сделали с обычными функциями. Но композиция - это кое-что получше.

Она выглядит так:

`example-9.html`

Здесь использована специальная форма yield*. Она применима только к другому генератору и делегирует ему выполнение.

То есть, при yield* интерпретатор переходит внутрь генератора аргумента, к примеру generateSequence(48, 57), выполняет его, и все yield, которые он делает выходят из внешнего генератора.

Получается - как будто мы вставили код внутреннего генератора во внешний напрямую, вот так:

`example-10.html`

Код выше по поведению полностью идентичен варианту с yield*. При этом, конечно, переменные вложенного генератора не попадают во внешний, "делегирование" только выводит результат yield во внешний поток.

Композиция - это естественное встраивание одного генератора в поток другого. При композиции значения из вложенного генератора выдаются "по мере готовности". Поэтому она будет работать даже если поток данных из вложеного генератора оказался бесконечным или ожидает какого-либо условия для завершения.

## yield - дорога в обе стороны

До этого генераторы наиболее напоминали "итераторы на стероидах". Но, как мы сейчас увидим, это не так, есть фундаментальное различие, генераторы гораздо мощьнее и гибче.

Всё дело в том что yield - дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор.

Вызов let result = yield value делает следующее:

* Возвращает value во внешний код, приостанавливая выполнение генератора.

* Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).

* Генератор продолжит выполнение, аргумент next будет возвращен как результат yield (и записан в result).

Продемонстрируем это на примере:

`example-11.html`

На рисунке ниже прямоугольником изображен генератор, а вокруг него - "внешний код", с ним взаимодействует:

На этой илюстрации показано то, что происходит в генераторе:

1. Первый вызов generator.next() - всегда без аргумента, он начинает выполнение и возвращает результат первого yield "2 + 2?". На этой точке генератор приостанавливает выполнение.

2. Результат yield переходит во внешний код (в question). Внешний код может выполнять любые асинхронные задачи, генератор стоит "на паузе".

3. Когда асинхронные задачи готовы, внешний код вызывает generator.next(4) с аргументом. Выполнение генератора возобновляется, а 4 выходит из присваивания как результат let result = yield ....

В примере выше только 2 next.

Увеличим их количество, чтобы стал более понятен общий поток выполнения:

`example-12.html`

Взаимодействие с внешним кодом:

1. Первый .next() начинает выполнение... Оно доходит до первого yield.

2. Результат возвращается во внешний код.

3. Второй .next(4) передает 4 обратно в генератор как результат первого yield и возобновляет выполнение.

4. ...Оно доходит до второго yield, который станет результатом .next(4).

5. Третий next(9) передает 9 в генератор как результат второго yield и возобновляет выполнение, которое завершается окончанием функции, так что done: true.

Получается "пинг-понг" каждый next(value) передает в генератор значение, которое становится результатом текущего yield, возобновляет выполнение и получает выражение из следующего yield. Исключение является первый вызов next, который не может передать значение в генератор, т.к. не было ни одного yield.

## generator.throw 

Как мы видели в примерах выше, внешний код может вернуть генератору в качестве результата yield любое значение.

... Но "вернуть" можно не только результат, но и ошибку!

Для того, чтобы передать в yield ошибку, используется вызов generator.throw(err). При этом на строке с yield возникает исключение.

Например, в коде ниже обращение к внешниму коду yield "Сколько будет 2 + 2" завершится с ошибкой:

`example-13.html`

"Выброшенная" в строке (*) ошибка возникает в строке с yield (**). Далее она обрабатывается как обычно. В примере выше она перехватывается try..catch и выводится.

Если ошибку не перехватить, то она "выпадает" из генератора. По стеку ближайший вызов, который инициировал выполнение - это строка с .throw. Можно прехватить ее там, как и продемонстрированно в примере ниже:

`example-14.html`

Если же ошибка и там не перехвачена, то дальше - как обычно, либо try..catch снаружи, либо она "повалит" скрипт.

## Плоский асинхронный код

Одна из основных областей применения генераторов - написание "плоского" асинхронного кода.

Общий принцип такой:

* Генератор yield-ит не просто значения, а промисы

* Есть специальная "функция-чернорабочий" execute(generator) которая запускает генератор, последовательными вызовами next получает из него промисы - один за другим, и, когда очередной промис выполняется, возвращает его результат в генератор следующим next.

* Последнее значение генератора (done: true) execute уже обрабатывает как окончательный результат - например, возвращает через промис куда-то еще, во внешний код или просто использует, как в примере ниже.

Напишем такой код для получения аватара пользователя с github и его вывода, аналогичный рассмотренному в статье про промисы.

Для AJAX-запросов будем использовать метод fetch, он как раз возвращает промисы.

`example-15.html`

Функция execute в примере выше - универсальная, она может работать с любым генератором, который yield'ит промимы.

Вместе с тем, это всего лишь набросок, чтобы было понятно, как такая фуцнкция в принцыпе работает. Есть уже готовые реализации, обладающие большим количеством возможностей.

Одна из самых известных - это библиотека co, которую мы рассмотрим далее.

## Билбиотека "co"

Библиотека co, как и execute в примере выше, получает генератор и выполняет его.

Начнем сразу с примера, а потом - детали и полезные возможности.

`example-16.html`

Предпологается что библиотека co подключена к странице, например отсюда:

http://cdnjs.com/libraries/co/. В примере выше function* () делает yield промиса с setTimeout, который через секунду возвращает 1.

Вызов co(...) возвращает промис с результатом генератора. Если в примере выше function* () что-то возвратит, то это можно будет получить через .then в результате co:

`example-17.html`

#### Обязательно нужен catch

Частая ошибка начинающих - вообще забыть про обработку результата co. Даже если результата нет, ошибки нужно обрабатывать через catch, иначе они подвиснут в промисе.

Такой код ничего не выведет:

`example-18.html`

Программист даже не узнает об ошибке. Особенно обидно, когда это опечатка или другая программная ошибка, которую обязательно нужно поправить.

Правильный вариант:

`example-19.html`

Большинство примеров этого catch не содержат, но это лишь потому, что в примерах ошибок нет. А в реальном коде обязательно нужен catch.

Библиотека co умеет выполнять не только промисы. Есть несколько видов значений, которые можно yield ить, и их обработает co:

* Промис.

* Обьект-генератор.

* Функция-генератор function* () - со ее выполнит, затем выполнит полученный генератор.

* Функция с единственным аргументом вида function (callback) - библиотека co ее запустит со своей функцией-callback и будет ожидать, что при ошибке она вызовет callback(err), а при успешном выполнении - callback(null, result). То есть, в первом аргументе будет ошибка (если есть), а втором - результат (если нет ошибки). После чего результат будет передан в генератор.

* Массив или обьект из вышеперечисленного. При этом все задачи будут выполнены параллельно, и результат, в той же структуре, будет выдан наружу.

В примере ниже происходит yield всех этих видов значений. Библиотека co обеспечивает их выполнение и возврат результата в генератор:

`example-20.html`

#### устаревший yield function(callback)

Отдельно заметим вариант с yield function(callback). Такие функции, с единственным-аргументом callback'ом, в англоязычной литературе называют "thunk".

Функция обязана выполниться и вызвать (асинхронно) либо callback(err) с ошибкой, либо callback(null, result) с результатом.

Использование таких функций в yield является устаревшим подходом, так как там, где можно использовать yield function (callback), можно использовать и промисы. При этом промисы мощьнее. Но в старом коде его еще можно встретить.

Посмотрим пример посложнее, с композицией генераторов:

`example-21.html`

Это отличный вариант для библиотеки co. Композиция yield* gen() вызывает gen() в потоке вашего генератора. Аналогично делает и yield* gen2().

Поэтому yield new Promise из строки (1) в gen2() попадает напрямую в библиотеку co, как если бы он был сделан так:

`example-22.html`

Пример showUserAvatar() можно переписать с использованием co вот так:

`example-23.html`

Заметим, что для перехвата ошибок при получении аватара используется try..catch вокруг yield* fetchAvatar:

    try {
        avatarUrl = yield* fetchAvatar('/article/generator/user.json');
    } catch (e) {
        avatarUrl = '/article/generator/anon.png';
    }

Это - одно из главных удобств использование генераторов. Несмотря на то, что операции fetch - асинхронные, мы можем использовать обычный try..catch для обработки ошибок в них.

## Для генераторов - только yield*

Библиотека co технически позволяет писать код так:

    let user = yield fetchUser(url);
    // вместо
    // let user = yield* fetchUser(url);

То есть, можно сделать yield генератора, co() его выполнит и передаст значение обратно. Как мы видели выше, библиотека co - довольно всеядна. Однако, рекомендуется использовать для вызова функций-генераторов именно yield*.

Причин для этого несколько:

1. Делегирование генераторов yield* - это встроенный механизм JavaScript. Вместо возвращения значений обратно в co, выполнение кода библиотеки... Мы просто используем возможности языка. Это правильнее.

2. Поскольку не происходит лишних вызовов, это быстрее по производительности.

3. И, наконец, пожалуй самое приятное - делегирование генераторов сохраняет стек.

Проилюстрируем последнее на примере:

`example-24.html`

При запуске этого кода стек может выглядеть примерно так:

    at g (eval at runJS …, <anonymous>:13:9)
        at GeneratorFunctionPrototype.next (native)
        at onFulfilled (…/co/…/index.min.js:1:1136)
        at …/co/…/index.min.js:1:1076
        at co (…/co/…/index.min.js:1:1039)
        at toPromise (…/co/…/index.min.js:1:1740)
        at next (…/co/…/index.min.js:1:1351)
        at onFulfilled (…/co/…/index.min.js:1:1172)
        at …/co/…/index.min.js:1:1076
        at co (…/co/…/index.min.js:1:1039)

Детали здесь не имеют значения, самое важное - почти весь стек находится внутри библиотеки co.

Из оригинального скрипта, там только одна строка:

    at g(eval at runJS ..., <anonymus>:13:9)

То есть, стек говорит, что ошибка возникла в строке 13:

    throw new Error("my error");

Что ж, спасибо. Но как мы оказались на этой строке? Об этом в стеке нет ни слова!

Заменим в строке (*) вызов yield на yield*:

`example-25.html`

Пример стека теперь:

    at g (eval at runJS …, <anonymous>:13:9)
        at GeneratorFunctionPrototype.next (native)
        at eval (eval at runJS …, <anonymous>:6:10)
        at GeneratorFunctionPrototype.next (native)
        at onFulfilled (…/co/…/index.min.js:1:1136)
        at …/co/…/index.min.js:1:1076
        at co (…/co/…/index.min.js:1:1039)
        at eval (eval at runJS …, <anonymous>:3:1)
        at eval (native)
        at runJS (…)

Если очистить от вспомогательных вызовов, то эти строки - как раз то, что нам надо:

    at g (eval at runJS …, <anonymous>:13:9)
        at eval (eval at runJS …, <anonymous>:6:10)
        at eval (eval at runJS …, <anonymous>:3:1)

Теперь видно, что (читаем снизу) исходный вызов был в строке 3, далее - вложенный в строке 6, и затем произошла ошибка в строке 13.

Почему вариант с простым yield не работает - достаточно очевидно, если внимательно посмотреть на код и воспроизвести в уме, как он функционирует. Оставляем это упражнение вдумчивому читателю.

Итого, рекомендация уже достаточно обоснована - при запуске вложенных генераторов используем yield*.

## Итого

* Генераторы создаются при помощи функций-генераторов function* (...) {...}.

* Внутри генераторов и только внутри них разрешен оператор yield. Это иногда создает неудобства, поскольку в коллбеках .map/.forEach сделать yield нельзя. Впрочем можно сделать yield массива (при помощи co).

* Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.

* Генераторы позволяют писать плоский асинхронный код, при помощи библиотеки co.

Что касается кросс-браузерной поддержки - она стремительно приближается. Пока же можно использовать генераторы вместе с Babel.