# Строки

Есть ряд улучшений и новых методов для строк.

Начнём с, пожалуй, самого важного.

## Строки-шаблоны

Добавлен новый вид кавычек для строк:

`example-1.html`

Основные отличия от двойных "…" и одинарных '…' кавычек:

#### * В них разрешён перевод строки.

Например:

`example-2.html`

Заметим, что пробелы и, собственно, перевод строки также входят в строку, и будут выведены.

#### * Можно вставлять выражения при помощи ${…}.

Например:

`example-3.html`

Как видно, при помощи ${…} можно вставлять как и значение переменной ${apples}, так и более сложные выражения, которые могут включать в себя операторы, вызовы функций и т.п. Такую вставку называют «интерполяцией».

## Функции шаблонизации

Можно использовать свою функцию шаблонизации для строк.

Название этой функции ставится перед первой обратной кавычкой:

    let str = func`моя строка`

Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров ${…} и сами эти параметры.

Например:

`example-4.html`

В примере выше видно, что строка разбивается по очереди на части: «кусок строки» – «параметр» – «кусок строки» – «параметр».

* Участки строки идут в первый аргумент-массив strings.

* У этого массива есть дополнительное свойство strings.raw. В нём находятся строки в точности как в оригинале. Это влияет на спец-символы, например в strings символ \n – это перевод строки, а в strings.raw – это именно два символа \n.

* Дальнейший список аргументов функции шаблонизации – это значения выражений в ${...}, в данном случае их три.

#### Зачем strings.raw?

В отличие от strings, в strings.raw содержатся участки строки в «изначально введённом» виде.

То есть, если в строке находится \n или \u1234 или другое особое сочетание символов, то оно таким и останется.

Это нужно в тех случаях, когда функция шаблонизации хочет произвести обработку полностью самостоятельно (свои спец. символы?). Или же когда обработка спец. символов не нужна – например, строка содержит «обычный текст», набранный непрограммистом без учёта спец. символов.

Как видно, функция имеет доступ ко всему: к выражениям, к участкам текста и даже, через strings.raw – к оригинально введённому тексту без учёта стандартных спец. символов.

Функция шаблонизации может как-то преобразовать строку и вернуть новый результат.

В простейшем случае можно просто «склеить» полученные фрагменты в строку:

`example-5.html`

Функция str в примере выше делает то же самое, что обычные обратные кавычки. Но, конечно, можно пойти намного дальше. Например, генерировать из HTML-строки DOM-узлы (функции шаблонизации не обязательно возвращать именно строку).

Или можно реализовать интернационализацию. В примере ниже функция i18n осуществляет перевод строки.

Она подбирает по строке вида "Hello, ${name}!" шаблон перевода "Привет, {0}!" (где {0} – место для вставки параметра) и возвращает переведённый результат со вставленным именем name:

`example-6.html`

Итоговое использование выглядит довольно красиво, не правда ли?

Разумеется, эту функцию можно улучшить и расширить. Функция шаблонизации – это своего рода «стандартный синтаксический сахар» для упрощения форматирования и парсинга строк.

## Улучшена поддержка юникода

Внутренняя кодировка строк в JavaScript – это UTF-16, то есть под каждый символ отводится ровно два байта.

Но под всевозможные символы всех языков мира 2 байт не хватает. Поэтому бывает так, что одному символу языка соответствует два юникодных символа (итого 4 байта). Такое сочетание называют «суррогатной парой».

Самый частый пример суррогатной пары, который можно встретить в литературе – это китайские иероглифы.

Заметим, однако, что не всякий китайский иероглиф – суррогатная пара. Существенная часть «основного» юникод-диапазона как раз отдана под китайский язык, поэтому некоторые иероглифы – которые в неё «влезли» – представляются одним юникод-символом, а те, которые не поместились (реже используемые) – двумя.

Например:

`example-7.html`

В тексте выше для первого иероглифа есть отдельный юникод-символ, и поэтому длина строки 1, а для второго используется суррогатная пара. Соответственно, длина – 2.

Китайскими иероглифами суррогатные пары, естественно, не ограничиваются.

Ими представлены редкие математические символы, а также некоторые символы для эмоций, к примеру:

`example-8.html`

В современный JavaScript добавлены методы String.fromCodePoint и str.codePointAt – аналоги String.fromCharCode и str.charCodeAt, корректно работающие с суррогатными парами.

Например, charCodeAt считает суррогатную пару двумя разными символами и возвращает код каждой:

`example-9.html`

…В то время как codePointAt возвращает его Unicode-код суррогатной пары правильно:

`example-10.html`

Метод String.fromCodePoint(code) корректно создаёт строку из «длинного кода», в отличие от старого String.fromCharCode(code).

Например:

`example-11.html`

Более старый метод fromCharCode в последней строке дал неверный результат, так как он берёт только первые два байта от числа 119987 и создаёт символ из них, а остальные отбрасывает.

#### \u{длинный код}

Есть и ещё синтаксическое улучшение для больших Unicode-кодов.

В JavaScript-строках давно можно вставлять символы по Unicode-коду, вот так:

`example-12.html`

Синтаксис: \uNNNN, где NNNN – четырёхзначный шестнадцатиричный код, причём он должен быть ровно четырёхзначным.

«Лишние» цифры уже не войдут в код, например:

`example-13.html`

Чтобы вводить более длинные коды символов, добавили запись \u{NNNNNNNN}, где NNNNNNNN – максимально восьмизначный (но можно и меньше цифр) код.

Например:

`example-14.html`

## Unicode-нормализация

Во многих языках есть символы, которые получаются как сочетание основного символа и какого-то значка над ним или под ним.

Например, на основе обычного символа a существуют символы: àáâäãåā. Самые часто встречающиеся подобные сочетания имеют отдельный юникодный код. Но отнюдь не все.

Для генерации произвольных сочетаний используются несколько юникодных символов: основа и один или несколько значков.

Например, если после символа S идёт символ «точка сверху» (код \u0307), то показано это будет как «S с точкой сверху» Ṡ.

Если нужен ещё значок над той же буквой (или под ней) – без проблем. Просто добавляем соответствующий символ.

К примеру, если добавить символ «точка снизу» (код \u0323), то будет «S с двумя точками сверху и снизу» Ṩ .

Пример этого символа в JavaScript-строке:

`example-15.html`

Такая возможность добавить произвольной букве нужные значки, с одной стороны, необходима, а с другой стороны – возникает проблемка: можно представить одинаковый с точки зрения визуального отображения и интерпретации символ – разными сочетаниями Unicode-кодов.

Вот пример:

`example-16.html`

В первой строке после основы S идёт сначала значок «верхняя точка», а потом – нижняя, во второй – наоборот. По кодам строки не равны друг другу. Но символ задают один и тот же.

С целью разрешить эту ситуацию, существует юникодная нормализация, при которой строки приводятся к единому, «нормальному», виду.

В современном JavaScript это делает метод str.normalize().

`example-17.html`

Забавно, что в данной конкретной ситуации normalize() приведёт последовательность из трёх символов к одному: \u1e68 (S с двумя точками).

`example-18.html`

Это, конечно, не всегда так, просто в данном случае оказалось, что именно такой символ в юникоде уже есть. Если добавить значков, то нормализация уже даст несколько символов.

Для большинства практических задач информации, данной выше, должно быть вполне достаточно, но если хочется более подробно ознакомиться с вариантами и правилами нормализации – они описаны в приложении к стандарту юникод Unicode Normalization Forms.

## Полезные методы

Добавлен ряд полезных методов общего назначения:

* str.includes(s) - проверяет, включает ли одна строка в себя другую, возвращает true/false

* str.endsWith(s) - возвращает true, если строка str заканчивается подстрокой s

* str.startsWith(s) - возвращает true, если строка str начинается со строки s

* str.repeat(times) - повторяет строку str times раз

Конечно, всё это можно было сделать при помощи других встроенных методов, но новые методы более удобны.

## Итого

Улучшения:

* Строки-шаблоны – для удобного задания строк (многострочных, с переменными), плюс возможность использовать функцию шаблонизации для самостоятельного форматирования.

* Юникод – улучшена работа с суррогатными парами.

* Полезные методы для проверок вхождения одной строки в другую.