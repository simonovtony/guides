# Promise

Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.

В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.

## Что такое Promise

Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

На promise можно навешивать коллбэки двух типов:

* onFulfilled - срабатывает, когда promise в состоянии "выполнен успешно".

* onRejected - срабатывает, когда promise в состоянии "выполнен с ошибкой".

Способ использования, в общих чертах, такой:

1. Код, которому надо сделать что-то асинхронно, создает обьект promise и возвращает его.

2. Внешний код, получив promise, навешивает на него обработчики.

3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания Promise:

    var promise = new Promise(function (resolve, reject) {
        // Эта фнукция будет вызвана автоматически

        // В ней можно делать любые асинхронные операции,
        // А когда они завершатся - нужно вызвать одно из:
        // resolve(результат) при успешном выполнении
        // reject(ошибка) при ошибке
    })

Универсальный метод для навешивания обработчиков:

    promise.then(onFulfilled, onRejected)

* onFulfilled - функция, которая будет вызвана с результатом при resolve

* onRejected - функция, которая будет вызвана с ошибкой при reject.

С его помощью можно назначить как оба обработчика сразу, так и только один:

    // onFulfilled сработает при успешном выполнении
    promise.then(onFulfilled)
    // onRejected сработает при ошибке
    promise.then(null, onRejected)

#### .catch

Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) - это то же самое.

#### Синхронный throw - то же самое, что reject

Если функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:

    let p = new Promise((resolve, reject) => {
        // то же что reject(new Error("o_O"))
        throw new Error("o_O")
    });

    p.catch(alert); // Error: o_O

Посмотрим, как это выглядит вместе, на простом примере.

## Пример с setTimeout

Возьмем setTimeout в качестве асинхронной операции, которая должна через нескоторое время успешно завершиться с результатом "result":

`example-1.html`

В результате запуска кода выше - через 1 секунду выведется "Fulfilled: result".

А если бы вместо resolve("result") был вызов reject("error"), то вывелось бы "Rejected: error". Впрочем, как правило, если при выполнении возникла проблема, то reject вызывают не со строкой, а с обьектом ошибки типа new Error:

`example-2.html`

Конечно, вместо setTimeout внутри функции промиса может быть и запрос к серверу и ожидание ввода пользователя, или другой асинхронный процесс. Главное, что по своему завершению он вызовал resolve или reject, которые передадут результат обработчиками.

#### Только один аргумент

Функции resolve/reject принимают ровно один аргумент - результат/ошибку.

Именно он передается обработчиком в .then, как можно видеть в примерах выше.

## Promise после reject/resolve - неизменны

Змаетим, что после вызова resolve/reject промис уже не может "передумать".

Когда промис переходит в состояние "выполнен" - с результатом (resolve) или ошибка (reject) - это навсегда.

Например:

`example-3.html`

В результате вызова этого кода сработает только первый обработчик then, так как после вызова resolve промис уже получил состояние (с результатом), и в дальнейшем его уже ничто не изменит.

Последующие вызовы resolve/reject будут просто проигнорированы.

А так - наоборот, ошибка будет раньше:

`example-4.html`

## Промисификация

Промисификация - это когда берут асинхронный функционал и делают для него обертку, возвращающую промис.

После промисификации использование функционала зачастую становится гораздно удобнее.

В качестве примера сделаем такую обертку для запросов при помощи XMLHttpRequest.

Фнукция httpGet(url) будет возвращать промис, который при успешной загрузке данных с url будет переходить в fulfilled с этими данными, а при ошибке - в rejected с информаций об ошибке:

`example-5.html`

Как видно, внутри функции обьекта XMLHttpRequest создается и отсылается как обычно, при onload/onerror вызываются, соответственно, resolve(при статусе 200) или reject.

Использование:

`example-6.html`

## Цепочки промисов

"Чейнинг"(chaining), то есть возможность строить асинхронные цепочки из промисов - пожалуй, основная причина, из-за которой существуют и активно используются промисы.

Например, мы хотим по очереди:

1. Загрузить анные посетителя с сервера (асинхронно).

2. Затем отправить запрос о нем на github (асинхронно).

3. Когда это будет готово, вывести его github-аватар на экран (асинхронно).

4. ...И сделать код расширяемым, чтобы цепочку можно было легко продолжить.

Вот код для этого, использующий функцию httpGet, описанную выше:

`example-7.html`

Самое главное в этом коде - последовательность вызовов:

    httpGet(...)
        .then(...)
        .then(...)
        .then(...)

При чейнинге, то есть последовательных вызовах .then...then...then, в каждый следующий then переходит результат от предыдущего. Вызовы console.log оставлены, что бы при запуске можно было посмотреть конкретные значения, хотя они здесь и не очень важны.

#### Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.

В коде выше:

1. Функция в первом then возвращает "обычное" значение user. Это значит, что then возвратит промис в состоянии "выполнен" с user в качестве результата. Он станет аргументом в следующем then.

2. Функция во втором then возвращает промис (результат нового вызова httpGet). Когда он будет завершен (может пройти какое-то время), то будет вызван следующий then с его результатом.

3. Третий then ничего не возвращает.

Схематично его работу можно изобразить так:

Значком "песочные часы" помечены периоды ожидания, которых всего два: в исходном httpGet и в подвызове далее по цепочке.

Если then возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.

То есть, логика довольно проста:

* В каждом then мы получаем текущий результат работы

* Можно его обработать синхронно и вернуть результат (например, применить JSON.parse). Или же, если нужна асинхронная обработка - инициировать ее и вернуть промис.

Обратим внимание, что последний then в нашем примере ничего не возвращает. Если мы хотим, что бы после setTimeout (*) асинхронная цепочка могла быть продолжена, то последний then стартует новый асинхронный процесс, то для того, что бы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис.

В данном случае промис должен перейти в состояние "выполнен" после срабатывания setTimeout.

Строку (*) для этого нужно переписать так:

`example-8.html`

Теперь, если к цепочке добавить еще then, то он будет вызван после окончания setTimeout.

## Перехват ошибок

Выше мы рассмотрели "идеальный случай" выполнения, когда ошибок нет.

А что, если github не отвечает? Или JSON.parse бросил синтаксическую ошибку при обработке данных?

Да мало ли, где ошибка...

Правило здесь очень простое.

#### При возникновении ошибки - она отправляется в ближайший обработчик onRejected.

Такой обработчик нужно поставить через второй аргумент .then(..., onRejected) или, что то же самое, через .catch(onRejected).

Что бы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим catch в конец нашей цепочки:

`example-9.html`

В примере выше ошибка возникает в первом же httpGet, но catch с тем же успехом поймал бы ошибку во втором httpGet или в JSON.parse.

Принцып очень похож на обычный try...catch: мы делаем асинхронную цепочку из .then, а затем, в том месте кода, где нужно перехватить оишбки, вызываем .catch(onRejected).

#### А что после catch?

Обработчик .catch(onRejected) получает ошибку и должен обработать ее.

Есть два варианта развития событий:

1. Если ошибка не критичная, то onRejected возвращает значение через return, и управление переходит в ближайший .then(onFulfilled).

2. Если продолжить выполнение с такой ошибкой нельзя, то он делает throw, и тогда ошибка переходит в следующий ближайший .catch(onRejected).

Это также похоже на обычный try..catch - в блоке catch ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает throw. Существенное отличие - в том, что промисы асинхронные, поэтому при отсутствии внешнего .catch ошибка не "выплывается" в консоль и не "убивает" скрипт.

Ведь возможно, что новый обработчик .catch будет добавлен в цепочку позже.

## Промисы в деталях

Самым основным источником информации по промисам является, разумеется, стандарт.

Чтобы наше понимание промисов было полным, и мы могли с легкостью разрешать сложные ситуации, посмотрим внимательнее, что такое промис и как он работает, но уже не в общих словах, а детально, в соответствии со стандартом ECMAScript.

Согласно стандарту, у обьекта new Promise(executor) при создании есть четыре внутренних свойства:

* PromiseState - состояние, вначале "pending".

* PromiseResult - результат, при создании значения нет.

* PromiseFulfilledReactions - список функций-обработчиков успешного выполнения.

* PromiseRejectReactions - список функций-обработчиков ошибки.

Когда функция-executor вызывает reject или resolve, то PromiseState становится "resolved" или "rejected", а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь "PromiseJobs".

Эта очередь автоматически выполняется, когдаинтерпретатору "нечего делать". Иначе говоря, все функции-обработчики выполнятся асинхронно, одна за другой, по завершении текущего кода, примерно как setTimeout(..,0).

Исключени из этого правила - если resolve возвращает другой Promise. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним.

Добавляет обработчики в списки один метод: .then(onResolved, onRejected). Метод .catch(onRejected) - всего лишь сокращенная запись .then(null, onRejected).

Он делает следующее:

* Если PromiseState == 'pending', то есть промис еще не выполнен, то обработчики добавляются в соответствующие списки.

* Иначе обработчики сразу помещаются в очередь на выполнение.

Здесь важно, что обработчики можно добавлять в любой момент. Можно до выполнения промиса (они подождут), а можно - после (выполнятся в ближайшее время, через асинхронную очередь).

Например:

    // Промис выполнится сразу же
    var promise = new Promise((resolve, reject) => resolve(1));

    // PromiseState = 'resolved'
    // PromiseResult = 1

    // Добавили обработчик к выполненному промису
    promise.then(alert); // ...он сработает тут же

Разумеется, можно добавлять и много обработчиков на один и тот же промис:

    var promise = new Promise((resolve, reject) => resolve(1));

    promise.then(function f1(result) {
        alert(result);
        return 'f1';
    });

    promise.then(function f2(result) {
        alert(result);
        return 'f2';
    });

Вид обьекта promise после этого:

На этой иллюстрации можно увидеть добавленные нами обработчики f1, f2, а также - автоматически добавленные обработчики ошибок "Thrower".

Дело в том, что .then, если один из обработчиков не указан, добавляет его "от себя", сделующим способом:

* Для успешного выполнения функция Identity, которая выглядит как arg => arg, то есть возвращает аргумент без изменений.

* Для ошибки - функция Thrower, которая выглядит как arg => throw arg, то есть генерирует ошибку.

Это, по сути дела, формальность, но без нее некоторые особенности поведения промисов могут "не сойтись" в общую логику, поэтому мы упоминаем о ней здесь.

Обратим внимание, в этом примере намеренно не используется чейнинг. То есть, обработчики добавляются на один и тот же промис.

По этому оба alert выдадут одно значение 1.

Все функции из списка обработчиков вызываются с результатом промиса, одна за другой. Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса (PromiseResult) после установки не меняется.

Поэтому, чтобы продолжить работать с результатом, используется чейнинг.

#### Для того, чтобы результат обработчика передать следующей фнукции, .then создает новый промис и возвращает его.

В примере выше создается два таких промиса (т.к. два вызова .then), каждый из которых дает свою ветку выполнения:

Изначально эти новые промисы - "пустые", они ждут. Когда в будущем выполняются обработчики f1, f2, то их результат будет передан в новые промисы по стандартному принципу:

* Если вернется обычное значение (не промис), новый промис перейдет в "resolved" с ним.

* Если был throw, то новый промис перейдет в состояние "rejected" с ошибкой.

* Если вернется промис, то используем его результат (он может быть как resolved, так и rejected).

Дальше выполнится уже обработчики на новом промисе, и так далее.

Чтобы понять понять происходящее, посмотрим на цепочку, которая получается в процессе написания кода для показа github-аватара.

Первый промис и обработка его результата:

    httpGet('/article/promise/user.json')
        .then(JSON.parse)

Если промис завершился через resolve, то результат в JSON.parse, если reject - то в Thrower.

Как было сказано выше, Thrower - это стандартная внутренняя функция, которая автоматически используется, если второй обработчик не указан.

Можно считать что второй обработчик выглядит так:

    httpGet('/article/promise/user.json')
        .then(JSON.parse, err => throw err)

Заметим, что когда обработчик в промисах делает throw - в данном случае, при ошибке запроса,  то такая ошибка не "валит" скрипт и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик onRejected.

Добавим в код еще строку:

    httpGet('/article/promise/user.json')
        .then(JSON.parse)
        .then(user => httpGet(`https://api.github.com/users/${user.name}`))

Цепочка "выросла вниз":

Функция JSON.parse, либо возвращает обьект с данными, либо генерирует ошибку (что расценивается как reject).

Если все хорошо, то then(user => httpGet(...)) вернет новый промис, на который стоят уже два обработчика:

    httpGet('/article/promise/user.json')
        .then(JSON.parse)
        .then(user => httpGet(`https://api.github.com/users/${user.name}`))
        .then(
            JSON.parse,
            function avatarError(error) {
                if (error.code == 404) {
                    return { name: 'NoGithub', avatar_url: '/article/promise/anon.png'}
                } else {
                    throw error;
                }
            }
        )

Наконец-то хоть какая-то обработка ошибок!

Обработчик avatarError перехватит ошибки, которые были ранее. Функция httpGet при генерации ошибок записывает ее HTTP-код в свойство error.code, так что мы легко можем понять - что это:

* Если страница на github не найдена - можно продолжить выполнение, используя "аватар по умолчанию"

* Иначе - пробрасываем ошибку далее.

Итого, после добавления оставшейся части цепочки, картина проучается следующей

`example-10.html`

В конце срабатывает общий обработчик genericError, который перехватывает любые ошибки. В данном случае ошибки, которые в него попадут, уже носят критический характер, что-то серьезно не так. Чтобы посетитель не удивился отсутствию информации, мы показываем ему сообщение об этом.

Можно и как-то иначе вывести вывести уведомление о проблеме, главное - не забыть обработать ошибки в конце. Если последнего catch не будет, а цепочка завершится с ошибкой, то посетитель об этом не узнает.

В консоли тоже ничего не будет, так как ошибка остается "внутри" промиса, ожидая добавление следующего обработчика onRejected, которому будет передана.

Итак, мы рассмотрели основные приемы использования промисов. Далее - посмотрим некоторые полезные вспомогательные методы.

## Параллельное выполнение

Что, если мы хотим осуществить несколько асинхронных процессов одновременно и обработать их результат?

В классе Promise есть сделующие статические методы:

#### Promise.all(iterable)

Вызов Promise.all(iterable) получает массив (или другой итерируемый обьект) промисов и возвращает промис, который ждет, пока все переданные промисы завершаться, и переходит в состояние "выполнено" с массивом их результатов.

Например:

`example-11.html`

Допустим у нас есть массив с URL.

    let urls = [
        '/article/promise/user.json',
        '/article/promise/guest.json'
    ];

Что бы загрузить их параллельно, нужно:

1. Создать для каждого URL соответствующий промис.

2. Обернуть массив таких промисов в Promise.all.

Получится так:

`example-12.html`

Заметим, что если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются.

Например:

`example-13.html`

#### Promise.race(iterable)

Вызов Promise.race, как и Promise.all, получает итерируемый обьект с промисами, которые нужно выполнить, и возвращает новый промис.

Но в отличие от Promise.all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.

Например:

`example-14.html`

## Promise.resolve(value)

Вызов Promise.resolve(value) создает успешно выпонившийся промис с результатом value.

Он аналогичен конструкции:

    new Promise(resolve => resolve(value));

Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.

Например:

`example-15.html`

## Promise.reject(value)

Аналогично Promise.reject(error) создает уже выполнившийся промис, но не с успешным результатом, а с ошибкой error.

Например:

`example-16.html`

Метод Promise.reject используется очень редко, гораздо реже чем resolve, потому что ошибка возникает обычно не в начале цепочки, а в процессе ее выполнения.

## Итого

* Промис - это специальный обьект, который хранит свое состояние, текущий результат (если есть) и коллбэки.

* При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, которая должна вызвать resolve(result) при успешном выполнении и reject(error) - при ошибке.

* Аргумент resolve/reject (только первый, остальные игнорируются) передается обработчикам на этом промисе.

* Обработчики назначаются вызовом .then/catch.

* Для передачи результата от одного обработчика к другому используется чейнинг.

У промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для "отмены" промиса, хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.

В современной JavaScript разработке сложные цепочки с промисами используются редко, так как они куда проще описуются при помощи генераторов с библиотекой co, которые рассмотрены в соответствующей главе. Можно сказать, что промисы лежать в основе более продвинутых способов асинхронной разработки.

