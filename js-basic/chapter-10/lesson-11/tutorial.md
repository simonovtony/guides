# Promise

Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.

В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.

## Что такое Promise

Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

На promise можно навешивать коллбэки двух типов:

* onFulfilled - срабатывает, когда promise в состоянии "выполнен успешно".

* onRejected - срабатывает, когда promise в состоянии "выполнен с ошибкой".

Способ использования, в общих чертах, такой:

1. Код, которому надо сделать что-то асинхронно, создает обьект promise и возвращает его.

2. Внешний код, получив promise, навешивает на него обработчики.

3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания Promise:

    var promise = new Promise(function (resolve, reject) {
        // Эта фнукция будет вызвана автоматически

        // В ней можно делать любые асинхронные операции,
        // А когда они завершатся - нужно вызвать одно из:
        // resolve(результат) при успешном выполнении
        // reject(ошибка) при ошибке
    })

Универсальный метод для навешивания обработчиков:

    promise.then(onFulfilled, onRejected)

* onFulfilled - функция, которая будет вызвана с результатом при resolve

* onRejected - функция, которая будет вызвана с ошибкой при reject.

С его помощью можно назначить как оба обработчика сразу, так и только один:

    // onFulfilled сработает при успешном выполнении
    promise.then(onFulfilled)
    // onRejected сработает при ошибке
    promise.then(null, onRejected)

#### .catch

Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) - это то же самое.

#### Синхронный throw - то же самое, что reject

Если функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:

    let p = new Promise((resolve, reject) => {
        // то же что reject(new Error("o_O"))
        throw new Error("o_O")
    });

    p.catch(alert); // Error: o_O

Посмотрим, как это выглядит вместе, на простом примере.

## Пример с setTimeout

Возьмем setTimeout в качестве асинхронной операции, которая должна через нескоторое время успешно завершиться с результатом "result":

`example-1.html`

В результате запуска кода выше - через 1 секунду выведется "Fulfilled: result".

А если бы вместо resolve("result") был вызов reject("error"), то вывелось бы "Rejected: error". Впрочем, как правило, если при выполнении возникла проблема, то reject вызывают не со строкой, а с обьектом ошибки типа new Error:

`example-2.html`

Конечно, вместо setTimeout внутри функции промиса может быть и запрос к серверу и ожидание ввода пользователя, или другой асинхронный процесс. Главное, что по своему завершению он вызовал resolve или reject, которые передадут результат обработчиками.

#### Только один аргумент

Функции resolve/reject принимают ровно один аргумент - результат/ошибку.

Именно он передается обработчиком в .then, как можно видеть в примерах выше.

## Promise после reject/resolve - неизменны

Змаетим, что после вызова resolve/reject промис уже не может "передумать".

Когда промис переходит в состояние "выполнен" - с результатом (resolve) или ошибка (reject) - это навсегда.

Например:

`example-3.html`

В результате вызова этого кода сработает только первый обработчик then, так как после вызова resolve промис уже получил состояние (с результатом), и в дальнейшем его уже ничто не изменит.

Последующие вызовы resolve/reject будут просто проигнорированы.

А так - наоборот, ошибка будет раньше:

`example-4.html`

## Промисификация

Промисификация - это когда берут асинхронный функционал и делают для него обертку, возвращающую промис.

После промисификации использование функционала зачастую становится гораздно удобнее.

В качестве примера сделаем такую обертку для запросов при помощи XMLHttpRequest.

Фнукция httpGet(url) будет возвращать промис, который при успешной загрузке данных с url будет переходить в fulfilled с этими данными, а при ошибке - в rejected с информаций об ошибке:

`example-5.html`

Как видно, внутри функции обьекта XMLHttpRequest создается и отсылается как обычно, при onload/onerror вызываются, соответственно, resolve(при статусе 200) или reject.

Использование:

`example-6.html`

## Цепочки промисов

"Чейнинг"(chaining), то есть возможность строить асинхронные цепочки из промисов - пожалуй, основная причина, из-за которой существуют и активно используются промисы.

Например, мы хотим по очереди:

1. Загрузить анные посетителя с сервера (асинхронно).

2. Затем отправить запрос о нем на github (асинхронно).

3. Когда это будет готово, вывести его github-аватар на экран (асинхронно).

4. ...И сделать код расширяемым, чтобы цепочку можно было легко продолжить.

Вот код для этого, использующий функцию httpGet, описанную выше:

`example-7.html`

Самое главное в этом коде - последовательность вызовов:

    httpGet(...)
        .then(...)
        .then(...)
        .then(...)

При чейнинге, то есть последовательных вызовах .then...then...then, в каждый следующий then переходит результат от предыдущего. Вызовы console.log оставлены, что бы при запуске можно было посмотреть конкретные значения, хотя они здесь и не очень важны.

#### Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.

В коде выше:

1. Функция в первом then возвращает "обычное" значение user. Это значит, что then возвратит промис в состоянии "выполнен" с user в качестве результата. Он станет аргументом в следующем then.

2. Функция во втором then возвращает промис (результат нового вызова httpGet). Когда он будет завершен (может пройти какое-то время), то будет вызван следующий then с его результатом.

3. Третий then ничего не возвращает.

Схематично его работу можно изобразить так:

Значком "песочные часы" помечены периоды ожидания, которых всего два: в исходном httpGet и в подвызове далее по цепочке.

Если then возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.

То есть, логика довольно проста:

* В каждом then мы получаем текущий результат работы

* Можно его обработать синхронно и вернуть результат (например, применить JSON.parse). Или же, если нужна асинхронная обработка - инициировать ее и вернуть промис.

Обратим внимание, что последний then в нашем примере ничего не возвращает. Если мы хотим, что бы после setTimeout (*) асинхронная цепочка могла быть продолжена, то последний then стартует новый асинхронный процесс, то для того, что бы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис.

В данном случае промис должен перейти в состояние "выполнен" после срабатывания setTimeout.

Строку (*) для этого нужно переписать так:

`example-8.html`

Теперь, если к цепочке добавить еще then, то он будет вызван после окончания setTimeout.

## Перехват ошибок

