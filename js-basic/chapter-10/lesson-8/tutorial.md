# Тип данных Symbol

Новый примитивный тип данных Symbol служит для создания уникальных идентификаторов.

Мы вначале рассмотрим объявление и особенности символов, а затем – их использование.

## Обьявление

Синтаксис:

`example-1.html`

Обратим внимание, не new Symbol, а просто Symbol, так как это – примитив.

У символов есть и соответствующий typeof:

`example-2.html`

Каждый символ – уникален. У функции Symbol есть необязательный аргумент «имя символа». Его можно использовать для описания символа, в целях отладки:

`example-3.html`

…Но при этом, если у двух символов одинаковое имя, то это не значит, что они равны:

`example-4.html`

Если хочется из разных частей программы использовать именно одинаковый символ, то можно передавать между ними объект символа или же – использовать «глобальные символы» и «реестр глобальных символов», которые мы рассмотрим далее.

## Глобальные символы

Существует «глобальный реестр» символов, который позволяет, при необходимости, иметь общие «глобальные» символы, которые можно получить из реестра по имени.

Для чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя).

Например:

`example-5.html`

Таким образом, можно из разных частей программы, обратившись к реестру, получить единый глобальный символ с именем "name".

#### На заметку

В некоторых языках программирования, например Ruby, имя однозначно идентифицирует символ. В JavaScript, как мы видим, это верно для глобальных символов.

У вызова Symbol.for, который возвращает символ по имени, есть обратный вызов – Symbol.keyFor(sym). Он позволяет получить по глобальному символу его имя:

`example-6.html`

#### Symbol.keyFor возвращает undefined, если символ не глобальный

Заметим, что Symbol.keyFor работает только для глобальных символов, для остальных будет возвращено undefined:

`example-7.html`

Таким образом, имя символа, если этот символ не глобальный, не имеет особого применения, оно полезно лишь в целях вывода и отладки.

## Использование символов

Символы можно использовать в качестве имён для свойств объекта следующим образом:

`example-8.html`

Особенность символов в том, что если в объект записать свойство-символ, то оно не участвует в итерации:

`example-9.html`

Кроме того, свойство-символ недоступно, если обратиться к его названию: user.isAdmin не существует.

Зачем всё это, почему просто не использовать строки?

Резонный вопрос. На ум могут прийти соображения производительности, так как символы – это по сути специальные идентификаторы, они компактнее, чем строка. Но при современных оптимизациях объектов это редко имеет значение.

Самое широкое применение символов предусмотрено внутри самого стандарта JavaScript. В современном стандарте есть много системных символов. Их список есть в спецификации, в таблице Well-known Symbols. В спецификации для краткости символы принято обозначать как „@@имя“, например @@iterator, но доступны они как свойства Symbol.

Например:

* Symbol.toPrimitive – идентификатор для свойства, задающего функцию преобразования объекта в примитив.

* Symbol.iterator – идентификатор для свойства, задающего функцию итерации по объекту.

* ...и т.п.

#### Мы легко поймём смысл введения нового типа «символ», если поставим себя на место создателей языка JavaScript.

Допустим, в новом стандарте нам надо добавить к объекту «особый» функционал, например, функцию, которая задаёт преобразование объекта к примитиву. Как obj.toString, но для преобразования в примитивы.

Мы ведь не можем просто сказать, что «свойство obj.toPrimitive теперь будет задавать преобразование к примитиву и автоматически вызываться в таких-то ситуациях». Это опасно. Мы не можем так просто взять и придать особый смысл свойству. Мало ли, вполне возможно, что свойство с таким именем уже используется в существующем коде, и если сделать его особым, то он сломается.

Нельзя просто взять и зарезервировать какие-то свойства существующих объектов для нового функционала.

Поэтому ввели целый тип «символы». Их можно использовать для задания таких свойств, так как они:

a) уникальны

b) не учавствуют в циклах

c) заведомо не сломают старый код, который о них слыхом не слыхивал

Продемонстрируем отсутствие конфликта для нового системного свойства Symbol.iterator:

`example-10.html`

## Итого

* Символы – новый примитивный тип, предназначенный для уникальных идентификаторов.

* Все символы уникальны. Символы с одинаковым именем не равны друг другу.

* Существует глобальный реестр символов, доступных через метод Symbol.for("name"). Для глобального символа можно получить имя вызовом Symbol.keyFor(sym).

Основная область использования символов – это системные свойства объектов, которые задают разные аспекты их поведения. Поддержка у них пока небольшая, но она растёт. Системные символы позволяют разработчикам стандарта добавлять новые «особые» свойства объектов, при этом не резервируя соответствующие строковые значения.

Системные символы доступны как свойства функции Symbol, например Symbol.iterator.

Мы можем создавать и свои символы, использовать их в объектах. Записывать их как свойства Symbol, разумеется, нельзя. Если нужен глобально доступный символ, то используется Symbol.for(имя).