<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /**
     * Применение побитовых операторов
     */
    // Побитовые операторы ^, &, | выполняются после сравнений ==
    // В выражение a == b ^ 0 означает (a == b) ^ 0
    // Для изменения приоритета нужны скобки a == (b ^ 0)
    var a = 3;
    var b = 9;
    alert(a == b ^ 0); // (a == b) ^ 0
    alert(a == (b ^ 0));

    /**
     * Маска
     */
    var ACCESS_ADMIN = 1;          // 00001
    var ACCESS_GOODS_EDIT = 2;     // 00010
    var ACCESS_GOODS_VIEW = 4;     // 00100
    var ACCESS_ARTICLE_EDIT = 8;   // 01000
    var ACCESS_ARTICLE_VIEW = 16;  // 10000

    var guest  = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW;           // 10100
    var editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT;   // 11110
    var admin  = editor | ACCESS_ADMIN;                             // 11111

    alert(editor & ACCESS_ADMIN);        // 0, доступа нет
    alert(editor & ACCESS_ARTICLE_EDIT); // 8, доступ есть

    var check = ACCESS_GOODS_VIEW | ACCESS_GOODS_EDIT;
    alert(admin & check);

    /**
     * Округление
     */
    alert(~~12.345);   // 12
    alert(12.345 ^ 0); // 12
    alert(12.3 * 14.5 ^ 0); // (=178) "12.3 умножить на 14.5 и округлить"
    // У побитовых операций низкий приоритет, он меньше чем у арифметики и булевых
    alert(1.1 + 1.2 ^ 0);

    /**
     * Проверка на -1
     */
    // Внутренний формат 32-битных чисел устроен так, что для смены знака нужно все
    // биты заменить на противоположные («обратить») и прибавить 1.
    // Обращение битов – это побитовое НЕ (~). То есть, при таком формате представления
    // числа -n = ~n + 1. Или, если перенести единицу: ~n = -(n+1).
    // Как видно из последнего равенства, ~n == 0 только если n == -1.
    // Поэтому можно легко проверить равенство n == -1:
    var n = 5;
    if (~n) { // сработает, так как ~n = -(5 + 1) = -6
        alert("n не -1");
    }
    var n = -1;
    if (~n) { // не сработает, так как ~n = -(-1 + 1) = 0
        alert("... ничего не выведет ...");
    }
    ///////////////////////////////////
    var str = "Проверка";
    if (~str.indexOf('верка')) {
        alert('найдено!');
    }
    ///////////////////////////////////

    /**
     * Умножение и деление на степень 2
     */
    alert(1 << 2); // 1 * (2 * 2) = 4
    alert(1 << 3); // 1 * (2 * 2 * 2) = 8
    alert(3 << 3); // 3 * (2 * 2 * 2) = 24

    // При этом следует иметь в виду, что максимальный верхний порог такого умножения меньше,
    // чем обычно, так как побитовый оператор манипулирует 32-битными целыми, в то время
    // как обычные операторы работают с числами длиной 64 бита.

    alert( 8 >> 2 ); // 2 = 8/4, убрали 2 нуля в двоичном представлении
    alert( 11 >> 2 ); // 2, целочисленное деление (менее значимые биты просто отброшены)
</script>
</body>
</html>