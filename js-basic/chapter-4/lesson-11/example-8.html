<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /****************************************
     * Бенчмаркинг
     ****************************************/

    /**
     * !!! Более точное время с performance.now()
     * В современных браузерах (кроме IE9-) вызов performance.now() возвращает количество миллисекунд,
     * прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился
     * HTML-файл, если точнее – с момента выгрузки предыдущей страницы из памяти.
     * Так что это время включает в себя всё, включая начальное обращение к серверу.
     * Его можно посмотреть в любом месте страницы, даже в <head>, чтобы узнать, сколько
     * времени потребовалось браузеру, чтобы до него добраться, включая загрузку HTML.
     * Возвращаемое значение измеряется в миллисекундах, но дополнительно имеет точность 3
     * знака после запятой (до миллионных долей секунды!), поэтому можно использовать его
     * и для более точного бенчмаркинга в том числе.
     */
    alert(performance.now());

    /**
     * !!! console.time(метка) и console.timeEnd(метка)
     *
     * Для измерения с одновременным выводом результатов в консоли есть методы:
     * 1) console.time(метка) – включить внутренний хронометр браузера с меткой.
     * 2) console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.
     *
     * Параметр "метка" используется для идентификации таймера, чтобы можно было
     * делать много замеров одновременно и даже вкладывать измерения друг в друга.
     *
     * В коде ниже таймеры walkIn, walkLength – конкретные тесты,
     * а таймер «All Benchmarks» – время «на всё про всё»:
     */
    var arr = [];
    for (var i = 0; i < 1000; i++) arr[i] = 0;

    function walkIn(arr) {
        for (var key in arr) arr[key]++;
    }

    function walkLength(arr) {
        for (var i = 0; i < arr.length; i++) arr[i]++;
    }

    function bench(f) {
        for (var i = 0; i < 10000; i++) f(arr);
    }

    console.time('All Benchmarks');

    console.time('walkIn');
    bench(walkIn);
    console.timeEnd('walkIn');

    console.time('walkLength');
    bench(walkLength);
    console.timeEnd('walkLength');

    console.timeEnd('All Benchmarks');

    /**
     * При запуске этого примера нужно открыть консоль, иначе вы ничего не увидите.
     */

    /**
     * !!! Внимание, оптимизатор!
     *
     * Современные интерпретаторы JavaScript делают массу оптимизаций, например:
     *
     * 1) Автоматически выносят инвариант, то есть постоянное в цикле
     *      значение типа arr.length, за пределы цикла.
     * 2) Стараются понять, значения какого типа хранит данная переменная
     *      или массив, какую структуру имеет объект и, исходя из этого,
     *      оптимизировать внутренние алгоритмы.
     * 3) Выполняют простейшие операции, например сложение явно заданных
     *      чисел и строк, на этапе компиляции.
     * 4) Могут обнаружить, что некий код, например присваивание к неиспользуемой
     *      локальной переменной, ни на что не влияет и вообще исключить
     *      его из выполнения, хотя делают это редко.
     *
     * Эти оптимизации могут влиять на результаты тестов, поэтому измерять скорость базовых
     * операций JavaScript («проводить микробенчмаркинг») до того, как вы изучите внутренности
     * JavaScript-интерпретаторов и поймёте, что они реально делают на таком коде, не рекомендуется.
     */
</script>
</body>
</html>