<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /*******************************************
     * reduce/reduceRight
     *******************************************/

    /**
     * Метод «arr.reduce(callback[, initialValue])» используется для последовательной
     * обработки каждого элемента массива с сохранением промежуточного результата.
     * Это один из самых сложных методов для работы с массивами. Но его стоит освоить,
     * потому что временами с его помощью можно в несколько строк решить задачу, которая
     * иначе потребовала бы в разы больше места и времени.
     * Метод reduce используется для вычисления на основе массива какого-либо
     * единого значения, иначе говорят «для свёртки массива».
     * Чуть далее мы разберём пример для вычисления суммы.
     * Он применяет функцию callback по очереди к каждому элементу массива
     * слева направо, сохраняя при этом промежуточный результат.
     * Аргументы функции callback(previousValue, currentItem, index, arr):
     * 1) previousValue - последний результат вызова функции, он же «промежуточный результат.
     * 2) currentItem - текущий элемент массива, элементы перебираются по очереди слева-направо.
     * 3) index - номер текущего элемента.
     * 4) arr – обрабатываемый массив.
     *
     * Кроме callback, методу можно передать «начальное значение» – аргумент initialValue.
     * Если он есть, то на первом вызове значение previousValue будет равно initialValue,
     * а если у reduce нет второго аргумента, то оно равно первому
     * элементу массива, а перебор начинается со второго.
     * Проще всего понять работу метода reduce на примере.
     * Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.
     * Вот решение в одну строку:
     */
    var arr = [1, 2, 3, 4, 5];
    var result = arr.reduce(function (sum, current) {
        return sum + current;
    }, 0);
    alert(result);

    /**
     * Разберём, что в нём происходит.
     * При первом запуске sum – исходное значение, с которого начинаются
     * вычисления, равно нулю (второй аргумент reduce).
     * Сначала анонимная функция вызывается с этим начальным значением и
     * первым элементом массива, результат запоминается и передаётся в следующий
     * вызов, уже со вторым аргументом массива, затем новое значение участвует
     * в вычислениях с третьим аргументом и так далее.
     * Поток вычислений получается такой
     * 	                sum	current	результат
     * первый вызов	    0	1	    1
     * второй вызов	    1	2	    3
     * третий вызов	    3	3	    6
     * четвёртый вызов	6	4	    10
     * пятый вызов	    10	5	    15
     *
     * Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.
     * Кстати, полный набор аргументов функции для reduce включает в себя function(sum, current, i, array),
     * то есть номер текущего вызова i и весь массив arr, но здесь в них нет нужды.
     * Посмотрим, что будет, если не указать initialValue в вызове arr.reduce:
     */
    var arr = [1, 2, 3, 4, 5];
    var result = arr.reduce(function (sum, current) {
        return sum + current;
    });
    alert(result);

    /**
     * Результат – точно такой же! Это потому, что при отсутствии initialValue в
     * качестве первого значения берётся первый элемент массива, а перебор стартует со второго.
     * Таблица вычислений будет такая же, за вычетом первой строки.
     * Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.
     */
</script>
</body>
</html>