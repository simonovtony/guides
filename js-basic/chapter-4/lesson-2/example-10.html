<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /********************************************
     * Неточные вычисления
     ********************************************/

    /**
     * Запустите этот пример
     */
    alert(0.1 + 0.2 == 0.3); // false

    /**
     * Запустили? Если нет – все же сделайте это.
     * Ок, вы запустили его. Он вывел false. Результат несколько странный,
     * не так ли? Возможно, ошибка в браузере? Поменяйте браузер, запустите еще раз.
     * Хорошо, теперь мы можем быть уверены: 0.1 + 0.2 это не 0.3. Но тогда что же это?
     */
    alert(0.1 + 0.2); // 0.30000000000004

    /**
     * Как видите, произошла небольшая вычислительная ошибка, результат сложения 0.1 + 0.2 немного больше, чем 0.3.
     */
    alert(0.1 + 0.2 > 0.3); // true

    /**
     * Всё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.
     * Число 0.1 (одна десятая) записывается просто в десятичном формате. Но в двоичной системе счисления
     * это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится.
     * Также бесконечной дробью является 0.2 (=2/10).
     * Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность.
     * Её даже можно увидеть:
     */
    alert(0.1.toFixed(20)); // 0.10000000000000000555

    /**
     * Когда мы складываем 0.1 и 0.2, то две неточности складываются,
     * получаем незначительную, но всё же ошибку в вычислениях.
     * Конечно, это не означает, что точные вычисления для таких чисел невозможны. Они возможны. И даже необходимы.
     * Например, есть два способа сложить 0.1 и 0.2:
     */

    /**
     * 1. Сделать их целыми, сложить, а потом поделить:
     * Это работает, так как числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно представлены в двоичной системе.
     */
    alert((0.1 * 10 + 0.2 * 10) / 10); // 0.3

    /**
     * 2. Сложить, а затем округлить до разумного знака после запятой.
     * Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:
     */
    var result = 0.1 + 0.2;
    alert(+result.toFixed(10)); // 0.3

    /**
     * Забавный пример
     * Привет! Я – число, растущее само по себе!
     * Причина та же – потеря точности.
     * Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит
     * хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры,
     * то при записи пропадут младшие разряды.
     * Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число»,
     * что мы и видим в примере выше. Как говорится: «как смог, так записал».
     */
    alert(9999999999999999); // выведет 10000000000000000

    /**
     * Ради справедливости заметим, что в точности то же самое происходит в любом другом языке,
     * где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl.
     */
</script>
</body>
</html>