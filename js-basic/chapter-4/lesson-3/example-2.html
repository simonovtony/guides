<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /****************************************
     * Методы и свойства
     ****************************************/

    /**
     * Здесь мы рассмотрим методы и свойства строк, с некоторыми из которых
     * мы знакомились ранее, в главе Введение в методы и свойства.
     */

    /**
     * Длина length
     * Одно из самых частых действий со строкой – это получение ее длины:
     */
    var str = "My\n"; // 3 символа. Третий - перевод строки
    alert(str.length);

    /**
     * Доступ к символам
     * Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0:
     */
    var str = "jQuery";
    alert(str.charAt(0)); // "j"

    /**
     * В JavaScript нет отдельного типа «символ», так что charAt возвращает строку, состоящую из выбранного символа.
     * Также для доступа к символу можно использовать квадратные скобки:
     */
    var str = "Я - современный браузер!";
    alert(str[0]);

    /**
     * Разница между этим способом и charAt заключается в том, что если символа нет – charAt
     * выдает пустую строку, а скобки – undefined:
     */
    alert("".charAt(0)); // пустая строка
    alert(""[0]); // undefined

    /**
     * Вообще же метод charAt существует по историческим причинам, ведь квадратные скобки – проще и короче.
     * Вызов метода – всегда со скобками
     * Обратите внимание, str.length – это свойство строки, а str.charAt(pos) – метод, т.е. функция.
     * Обращение к методу всегда идет со скобками, а к свойству – без скобок.
     */

    /**
     * Изменение строк
     * Содержимое строки в JavaScript нельзя изменять. Нельзя взять символ посередине и заменить его.
     * Как только строка создана – она такая навсегда.
     * Можно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:
     */
    var str = "строка";
    str = str[3] + str[4] + str[5];
    alert(str); // ока

    /**
     * Смена регистра
     * Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний:
     */
    alert('Интерфейс'.toUpperCase()); // ИНТЕРФЕЙС

    /**
     * Пример ниже получает первый символ и приводит его к нижнему регистру:
     */
    alert('Интерфейс'[0].toLowerCase()); // и

    /**
     * Поиск подстроки
     * Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
     * Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено. Например:
     */
    var str = "Widget with id";
    alert(str.indexOf("Widget")); // 0, т.к. "Widget" найден прямо в начале str
    alert(str.indexOf("id")); // 1, т.к. "id" найден, начиная с позиции 1
    alert(str.indexOf("widget")); // -1, не найдено, так как поиск учитывает регистр

    /**
     * Необязательный второй аргумент позволяет искать, начиная с указанной позиции.
     * Например, первый раз "id" появляется на позиции 1. Чтобы найти его следующее
     * появление – запустим поиск с позиции 2:
     */
    var str = "Widget with id";
    alert(str.indexOf("id", 2)); // 12, поиск начат с позиции 2

    /**
     * Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки.
     */

    /**
     * На заметку:
     * Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.
     * Дело в том, что вызов ~n эквивалентен выражению -(n+1), например:
     */
    alert(~2); // -(2 + 1) = -3
    alert(~1); // -(1 + 1) = -2
    alert(~0); // -(0 + 1) = -1
    alert(~-1); // -(-1 + 1) = 0

    /**
     * Как видно, ~n – ноль только в случае, когда n == -1.
     * То есть, проверка if ( ~str.indexOf(...) ) означает, что результат indexOf отличен от -1, т.е. совпадение есть.
     * Вот так:
     */
    var str = "Widget";
    if (!str.indexOf("get")) {
        alert('совпадение есть!');
    }

    /**
     * Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.
     * Однако, в данном случае, все в порядке. Просто запомните: '~' читается как «не минус один»,
     * а "if ~str.indexOf" читается как "если найдено".
     */

    /**
     * Поиск всех вхождений
     * Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только
     * получаем очередную позицию – начинаем следующий поиск со следующей.
     * Пример такого цикла:
     */
    var str = "Ослик Иа-Иа посмотрел на виадук";
    var target = "Иа";

    var pos = 0;
    while(true) {
        var foundPos = str.indexOf(target, pos);
        if (foundPos === -1) break;

        alert(foundPos);
        pos = foundPos + 1;
    }

    /**
     * Такой цикл начинает поиск с позиции 0, затем найдя подстроку на позиции foundPos,
     * следующий поиск продолжит с позиции pos = foundPos+1, и так далее, пока что-то находит.
     * Впрочем, тот же алгоритм можно записать и короче:
     */

    var str = "Ослик Иа-Иа посмотрел на виадук";
    var target = "Иа";

    var pos = 1;
    while ((pos = str.indexOf(target, pos + 1)) !== -1) {
        alert(pos);
    }

    /**
     * Взятие подстроки: substring, substr, slice
     * В JavaScript существуют целых 3 (!) метода для взятия подстроки, с небольшими отличиями между ними.
     */

    /**
     * substring(start [, end])
     * Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.
     * Если аргумент end отсутствует, то идет до конца строки:
     */
    var str = "stringify";
    alert(str.substring(0, 1)); // "s", символы с позиции 0 по 1 не включая 1.

    var str = 'stringify';
    alert(str.substring(2));

    /**
     * substr(start [, length])
     * Первый аргумент имеет такой же смысл, как и в substring, а второй
     * содержит не конечную позицию, а количество символов.
     * Если второго аргумента нет – подразумевается «до конца строки».
     */
    var str = 'stringify';
    str = str.substr(2, 4); // ring, со второй позиции 4 символа
    alert(str);

    /**
     * slice(start [, end])
     * Возвращает часть строки от позиции start до, но не включая, позиции end.
     * Смысл параметров – такой же как в substring.
     */

    /**
     * Отрицательные аргументы
     * Различие между substring и slice – в том, как они работают с отрицательными
     * и выходящими за границу строки аргументами:
     */

    /**
     * substring(start, end)
     * Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
     * Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
     */
    alert("testme".substring(-2)); // "testme", -2 становится 0

    alert("testme".substring(4, -1)); // "test"
    // -1 становится 0 -> получили substring(4, 0)
    // 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"

    /**
     * slice(start, end)
     * Отрицательные значения отсчитываются от конца строки:
     */
    alert("tesstme".slice(-2)); // "me", от 2 позиции с конца.

    alert("testme".slice(1, -1)); // "estm", от 1 позиции до первой с конца.

    /**
     * Это гораздо более удобно, чем странная логика substring.
     * Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-.
     * Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice:
     * он и отрицательные аргументы поддерживает и работает наиболее очевидно.
     */

</script>
</body>
</html>