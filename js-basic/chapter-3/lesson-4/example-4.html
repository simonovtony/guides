<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script>
    /** Пример в действии
     *
     Для запуска тестов нужны соответствующие JavaScript-библиотеки.
     Мы будем использовать:

     1) Mocha – эта библиотека содержит общие функции для тестирования, включая describe и it
     2) Chai – библиотека поддерживает разнообразные функции для проверок. Есть разные «стили» проверки результатов,
        с которыми мы познакомимся позже, на текущий момент мы будем использовать лишь assert.equal.
     3) Sinon – для эмуляции и хитрой подмены функций «заглушками», понадобится позднее.

     Эти библиотеки позволяют тестировать JS не только в браузере, но и на сервере Node.JS.
     Здесь мы рассмотрим браузерный вариант, серверный использует те же функции.

     Эту страницу можно условно разделить на четыре части:

     1) Блок <head> – в нём мы подключаем библиотеки и стили для тестирования, нашего кода там нет.
     2) Блок <script> с реализацией спецификации, в нашем случае – с кодом для pow.
     3) Далее подключаются тесты, файл test.js содержит describe("pow", ...), который был описан выше.
        Методы describe и it принадлежат библиотеке Mocha, так что важно, что она была подключена выше.
     4) Элемент <div id="mocha"> будет использоваться библиотекой Mocha для вывода результатов.
        Запуск тестов инициируется командой mocha.run().

     Пока что тесты не проходят, но это логично – вместо функции стоит «заглушка», пустой код.

     Пока что у нас одна функция и одна спецификация, но на будущее заметим, что если различных функций и
     тестов много – это не проблема, можно их все подключить на одной странице. Конфликта не будет, так как
     каждый функционал имеет свой блок describe("что тестируем"...). Сами же тесты обычно пишутся так,
     чтобы не влиять друг на друга, не делать лишних глобальных переменных.
     */

    /** Начальная реализация
     Пока что, как видно, тесты не проходят, ошибка сразу же. Давайте
     сделаем минимальную реализацию pow, которая бы работала нормально:
     */

    /** Исправление спецификации
     Функция, конечно, ещё не готова, но тесты проходят. Это ненадолго :)
     Здесь мы видим ситуацию, которая (и не обязательно при ленивом программисте!)
     бывает на практике – да, есть тесты, они проходят, но функция (увы!) работает неправильно.
     С точки зрения BDD, ошибка при проходящих тестах – вина спецификации.

     Их принципиальное различие в том, что если assert обнаруживает ошибку, то он тут же прекращает
     выполнение блока it. Поэтому в первом варианте, если вдруг первый assert «провалился», то про
     результат второго мы никогда не узнаем.
     */

    /** Таким образом, разделить эти тесты может быть полезно, чтобы мы получили больше информации о происходящем.
     Кроме того, есть ещё одно правило, которое желательно соблюдать.
     Один тест тестирует ровно одну вещь.
    */

    /** Вложенный describe
     *
     */
</script>
</body>
</html>